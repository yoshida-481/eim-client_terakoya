{
  "version": 3,
  "sources": ["../../../../../../node_modules/dot-prop/index.js"],
  "sourcesContent": ["const isObject = value => {\n  const type = typeof value;\n  return value !== null && (type === 'object' || type === 'function');\n};\nconst disallowedKeys = new Set(['__proto__', 'prototype', 'constructor']);\nconst digits = new Set('0123456789');\nfunction getPathSegments(path) {\n  const parts = [];\n  let currentSegment = '';\n  let currentPart = 'start';\n  let isIgnoring = false;\n  for (const character of path) {\n    switch (character) {\n      case '\\\\':\n        if (currentPart === 'index') {\n          throw new Error('Invalid character in an index');\n        }\n        if (currentPart === 'indexEnd') {\n          throw new Error('Invalid character after an index');\n        }\n        if (isIgnoring) {\n          currentSegment += character;\n        }\n        currentPart = 'property';\n        isIgnoring = !isIgnoring;\n        break;\n      case '.':\n        if (currentPart === 'index') {\n          throw new Error('Invalid character in an index');\n        }\n        if (currentPart === 'indexEnd') {\n          currentPart = 'property';\n          break;\n        }\n        if (isIgnoring) {\n          isIgnoring = false;\n          currentSegment += character;\n          break;\n        }\n        if (disallowedKeys.has(currentSegment)) {\n          return [];\n        }\n        parts.push(currentSegment);\n        currentSegment = '';\n        currentPart = 'property';\n        break;\n      case '[':\n        if (currentPart === 'index') {\n          throw new Error('Invalid character in an index');\n        }\n        if (currentPart === 'indexEnd') {\n          currentPart = 'index';\n          break;\n        }\n        if (isIgnoring) {\n          isIgnoring = false;\n          currentSegment += character;\n          break;\n        }\n        if (currentPart === 'property') {\n          if (disallowedKeys.has(currentSegment)) {\n            return [];\n          }\n          parts.push(currentSegment);\n          currentSegment = '';\n        }\n        currentPart = 'index';\n        break;\n      case ']':\n        if (currentPart === 'index') {\n          parts.push(Number.parseInt(currentSegment, 10));\n          currentSegment = '';\n          currentPart = 'indexEnd';\n          break;\n        }\n        if (currentPart === 'indexEnd') {\n          throw new Error('Invalid character after an index');\n        }\n\n      // Falls through\n\n      default:\n        if (currentPart === 'index' && !digits.has(character)) {\n          throw new Error('Invalid character in an index');\n        }\n        if (currentPart === 'indexEnd') {\n          throw new Error('Invalid character after an index');\n        }\n        if (currentPart === 'start') {\n          currentPart = 'property';\n        }\n        if (isIgnoring) {\n          isIgnoring = false;\n          currentSegment += '\\\\';\n        }\n        currentSegment += character;\n    }\n  }\n  if (isIgnoring) {\n    currentSegment += '\\\\';\n  }\n  switch (currentPart) {\n    case 'property':\n      {\n        if (disallowedKeys.has(currentSegment)) {\n          return [];\n        }\n        parts.push(currentSegment);\n        break;\n      }\n    case 'index':\n      {\n        throw new Error('Index was not closed');\n      }\n    case 'start':\n      {\n        parts.push('');\n        break;\n      }\n    // No default\n  }\n  return parts;\n}\nfunction isStringIndex(object, key) {\n  if (typeof key !== 'number' && Array.isArray(object)) {\n    const index = Number.parseInt(key, 10);\n    return Number.isInteger(index) && object[index] === object[key];\n  }\n  return false;\n}\nfunction assertNotStringIndex(object, key) {\n  if (isStringIndex(object, key)) {\n    throw new Error('Cannot use string index');\n  }\n}\nexport function getProperty(object, path, value) {\n  if (!isObject(object) || typeof path !== 'string') {\n    return value === undefined ? object : value;\n  }\n  const pathArray = getPathSegments(path);\n  if (pathArray.length === 0) {\n    return value;\n  }\n  for (let index = 0; index < pathArray.length; index++) {\n    const key = pathArray[index];\n    if (isStringIndex(object, key)) {\n      object = index === pathArray.length - 1 ? undefined : null;\n    } else {\n      object = object[key];\n    }\n    if (object === undefined || object === null) {\n      // `object` is either `undefined` or `null` so we want to stop the loop, and\n      // if this is not the last bit of the path, and\n      // if it didn't return `undefined`\n      // it would return `null` if `object` is `null`\n      // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n      if (index !== pathArray.length - 1) {\n        return value;\n      }\n      break;\n    }\n  }\n  return object === undefined ? value : object;\n}\nexport function setProperty(object, path, value) {\n  if (!isObject(object) || typeof path !== 'string') {\n    return object;\n  }\n  const root = object;\n  const pathArray = getPathSegments(path);\n  for (let index = 0; index < pathArray.length; index++) {\n    const key = pathArray[index];\n    assertNotStringIndex(object, key);\n    if (index === pathArray.length - 1) {\n      object[key] = value;\n    } else if (!isObject(object[key])) {\n      object[key] = typeof pathArray[index + 1] === 'number' ? [] : {};\n    }\n    object = object[key];\n  }\n  return root;\n}\nexport function deleteProperty(object, path) {\n  if (!isObject(object) || typeof path !== 'string') {\n    return false;\n  }\n  const pathArray = getPathSegments(path);\n  for (let index = 0; index < pathArray.length; index++) {\n    const key = pathArray[index];\n    assertNotStringIndex(object, key);\n    if (index === pathArray.length - 1) {\n      delete object[key];\n      return true;\n    }\n    object = object[key];\n    if (!isObject(object)) {\n      return false;\n    }\n  }\n}\nexport function hasProperty(object, path) {\n  if (!isObject(object) || typeof path !== 'string') {\n    return false;\n  }\n  const pathArray = getPathSegments(path);\n  if (pathArray.length === 0) {\n    return false;\n  }\n  for (const key of pathArray) {\n    if (!isObject(object) || !(key in object) || isStringIndex(object, key)) {\n      return false;\n    }\n    object = object[key];\n  }\n  return true;\n}\nexport function escapePath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  return path.replace(/[\\\\.[]/g, '\\\\$&');\n}\n\n// The keys returned by Object.entries() for arrays are strings\nfunction entries(value) {\n  if (Array.isArray(value)) {\n    return value.map((value, index) => [index, value]);\n  }\n  return Object.entries(value);\n}\nfunction stringifyPath(pathSegments) {\n  let result = '';\n  for (let [index, segment] of entries(pathSegments)) {\n    if (typeof segment === 'number') {\n      result += `[${segment}]`;\n    } else {\n      segment = escapePath(segment);\n      result += index === 0 ? segment : `.${segment}`;\n    }\n  }\n  return result;\n}\nfunction* deepKeysIterator(object, currentPath = []) {\n  if (!isObject(object)) {\n    if (currentPath.length > 0) {\n      yield stringifyPath(currentPath);\n    }\n    return;\n  }\n  for (const [key, value] of entries(object)) {\n    yield* deepKeysIterator(value, [...currentPath, key]);\n  }\n}\nexport function deepKeys(object) {\n  return [...deepKeysIterator(object)];\n}"],
  "mappings": "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",
  "names": ["value"]
}
